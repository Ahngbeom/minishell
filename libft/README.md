# Libft [![bahn's 42Project Score](https://badge42.herokuapp.com/api/project/bahn/Libft)](https://github.com/JaeSeoKim/badge42)
[Libftest](https://github.com/jtoty/Libftest)

위 저장소의 테스트 프로그램을 사용했다. 가장 기본적이고, bonus 파트의 함수들까지 테스트가 가능하다.

[libft-unit-test](https://github.com/alelievr/libft-unit-test)

메모리 누수, segmentation fault, 오버플로우 여부를 확인할 수 있다. 실제 함수들과의 처리 속도를 비교해주는 bench mode도 지원한다.

[libft-war-machine](https://github.com/ska42/libft-war-machine)

워머신 이름값 한다. 세 개의 테스트 프로그램 중 가장 깐깐하게 체크한다. 여기서 OK 떴으면 뮬리넷도 OK를 준다. 다만 bonus 파트를 지원하지 않는 점이 아쉽다.

# Libft 최종 리뷰

## Makefile
<a href="https://velog.io/@cos/Make-%EA%B2%89-%ED%95%A5%EA%B8%B0">
참고자료 - Make 겉핥기
</a>
<hr>

변수 = 값
   
* Rule
  * Target : Prerequisites
            Command
            ...
            ...

  Make에서 룰이 실행되는 조건은 다음과 같습니다.
  * 타겟 파일이 프로젝트 폴더 안에 없을 때
  * Prerequisites에 변경점이 발생했을 때

OBJ = file_a.o file_b.o file_c.o

%.o : %.c
      gcc $< -o $@

커멘드 중 $<와 $@는 Make에서 제공하는 자동 변수입니다. 

@는 타겟을 저장하는 변수이고, 

$<는 첫 prerequisite를 저장하는 변수입니다. 

그렇다면 패턴 룰에 있는 커멘드는 gcc file_a.c -o file_a.o로 대체되어 실행됩니다.

.c.o : make에 내장이 되어있는 기능이기 때문에 .c 파일을 자동으로 .o파일로 만든다.

<img src="https://t1.daumcdn.net/cfile/tistory/253E224B56E5924D28">
<a href="https://bowbowbow.tistory.com/12">참고자료 - make와 Makefile 멍멍멍</a>

<hr>

## isalpha
    알파벳(대/소문자) 구별
## isdigit
    숫자(자릿수 0 ~ 9) 구별
## isalnum
    알파벳 또는 숫자 구별
## isascii
    아스키 코드(0 ~ 127) 구별
## isprint
    아스키 코드 중 출력 가능 문자 구별
## toupper
    알파벳 대문자 변환
## tolower
    알파벳 소문자 변환
   
## strlen
    문자열 길이 계산

    문자열의 널 종료 문자를 만날 때까지 count 변수를 증가시키며 길이를 계산.

## strlcpy
    문자열 복사
    
    널 종료 문자까지 포함하여 복사할 길이를 매개변수 인자로 넘겨준다.

## strlcat
    문자열 연결
    
    널 종료 문자까지 포함하여 복사할 길이를 매개변수 3번째 인자로 넘겨준다.

    반환 값은 size가 dest의 길이보다 작을 경우 복사하지 않고 src의 길이와 size의 합을 반환.

    size가 dest의 길이보다 크거나 같은 경우 복사한 후 기존 dest의길이와 src의 길이의 합을 반환. 
    
    (size와 dest의 길이(널 종료 문자 포함)가 같은 경우 함수 내 복사 역할을 하는 while 문을 수행하지 않음)

## strchr
    문자열 中 문자 탐색

    문자열의 첫번째 인덱스부터 탐색하여 c 문자가 가장 처음 나오는 인덱스의 주소를 반환.

    찾지 못했을 경우 NULL 포인터 반환.

    예외처리 - 찾을 문자가 '\0' 널 종료 문자일 경우 널 종료 문자를 만날 때까지 수행하는 while문 종료 후 if 조건문을 통해 검사. 

## strrchr
    역순으로 문자열 中 문자 탐색

    문자열의 마지막 인덱스부터 탐색하여 c 문자가 가장 처음 나오는 인덱스의 주소를 반환.
    찾지 못했을 경우 NULL 포인터 반환.
    
    찾을 문자가 '\0' 널 종료 문자일 경우 while문에서 탐색 가능.

## strnstr
    문자열 中 문자열 탐색

    찾을 범위 길이 값을 3번째 매개변수 인자로 넘겨준다.

    만약 찾을 문자열 src가 비어있을 경우 찾을 대상 문자열 dest를 그대로 반환한다.

    인덱스 변수 i를 통해 dest의 문자열을 탐색하면서 src의 첫번째 문자와 동일한지를 먼저 검사한다.

    동일할 경우 i는 고정시키고 다른 인덱스 변수 j를 통해 각 문자열의 다음 문자들이 동일한지를 검사한다. 
    
    이때 size를 잊어선 안된다. 
    
    i와 j의 합을 계산하여 size와 비교하며 문자들을 검사해야한다.

    모두 동일하다면 dest에서 찾은 문자열의 인덱스 주소를 반환한다.

    원하는 문자열을 찾지 못했다면 널 포인터를 반환한다.  

## atoi
    문자열을 정수 타입으로 변환

    문자열 처음에 공백이 있을 경우 변환할 문자의 위치 주소로 변경한다.

    만약 변환할 문자가 부호나 숫자가 아닐 경우 if문과 while문을 건너 뛰며 0을 반환한다.
    
    또, 부호와 숫자 사이 또는 숫자와 숫자 사이에 변환하지 못하는 문자가 포함되어있다면 변환 과정을 중단하고 중단하기 전까지의 변환한 값을 반환한다.

    변환한 값이 INT 형의 오버/언더플로우가 발생한다면 각각 -1/0을 리턴한다.

    하지만 기존 atoi 함수에 오버/언더플로우 값을 넘겨주게되면 -1/0이 아닌 다른 값이 나오게된다.

    그 이유는 atoi함수가 libc에 의해 stdtol()이라는 함수를 내부적으로 실행시켜 결과값을 리턴하는 방식이라고 한다.

    아직 우리가 접근하기엔 어렵기 때문에 굳이 당장은 신경안써도 된다고 한다.

## memset
    기존 메모리 공간 접근 및 설정

    이미 메모리에 할당된 공간에 특정 값을 특정 크기만큼 채워넣는 함수이다.

    ▶매개변수 
    #1. 채우고자 하는 메모리의 포인터(시작 주소)는 void *형.

    #2. 메모리에 채우고자 하는 값. int 형이지만 내부에서는 unsigned char(1byte)로 변환되어진 후 저장된다.

    #3. 채우고자 하는 바이트 수(메모리 크기).

    unsigned char *형 변수를 1개 선언하여 s에 접근한다.

    while문을 통해 n만큼 ptr(s)가 가리키는 값을 c를 대입 또는 c로 대체한다.

    그 후 s 리턴.

## bzero
    기존 메모리 공간 접근 및 설정

    이미 메모리에 할당된 공간에 0('\0', 널 종료 문자)을 특정 크기만큼 채워넣는 함수이다.

    ▶매개변수 
    #1. 채우고자 하는 메모리의 포인터(시작 주소)는 void *형.

    #2. 채우고자 하는 바이트 수(메모리 크기).

    unsigned char *형 변수를 1개 선언하여 s에 접근한다.

    while문을 통해 n만큼 ptr(s)가 가리키는 값에 0으로 대입 또는 0으로 대체한다.

    그 후 s 리턴.
    
## memcpy
    2개의 기존에 존재하는 메모리 공간 간의 데이터 복사

    dest는 복사되어질 메모리 주소.
    
    src는 복사할 데이터가 저장되어있는 메모리 주소.

    n은 복사할 바이트 크기

    dest와 src는 unsigned char 형으로 데이터가 저장되어져있거나 저장되기때문에 각각의 주소에 접근하기 위한 unsigned char *형 포인터 변수를 선언하고 dest와 src를 unsigned char *형으로 형변환 후 초기화 시켜준다.

    while문을 통해 n만큼 각각 dptr(dest)이 가리키는 데이터 주소에 sptr(src)이 가리키는 데이터를 복사한다.

    dest 시작 주소를 반환

## memccpy
    2개의 기존에 존재하는 메모리 공간 간의 특정 문자까지 데이터 복사

    dest는 복사되어질 메모리 주소.
    
    src는 복사할 데이터가 저장되어있는 메모리 주소.

    c는 특정 문자. 즉, src 데이터 중 c가 존재할 경우 n과 상관없이 c까지 복사한다.

    n은 복사할 바이트 크기

    dest와 src는 unsigned char 형으로 데이터가 저장되어져있거나 저장되기때문에 각각의 주소에 접근하기 위한 unsigned char *형 포인터 변수를 선언하고 dest와 src를 unsigned char *형으로 형변환 후 초기화 시켜준다.

    while문을 통해 n만큼 각각 dptr(dest)이 가리키는 데이터 주소에 sptr(src)이 가리키는 데이터를 복사한다.

    단, 복사 과정 후 sptr이 가리키는 데이터가 c와 동일할 경우 복사 과정을 중단 후 복사한 데이터의 다음 주소를 리턴해준다.

    추가 복사 과정을 쉽게 하기위해서이다.

    만약 c와 동일한 문자가 없을 경우 NULL을 리턴한다. (복사는 정상적으로 n만큼 완료)

## memmove
    메모리 복사. 특정 조건에 따라 복사 데이터 순서가 다르다.

    먼저 dest나 src가 NULL일 경우 NULL을 반환한다.

    NULL이 아니라면 dest와 src의 주소를 비교해야한다.

    dest주소가 src주소보다 작거나 같다면 dest의 시작주소부터 src의 시작주소에 있는 데이터부터 복사한다.

    dest 주소가 src주소보다 크다면 dest의 끝 주소부터 src의 끝 주소에 있는 데이터부터 역순으로 복사한다.

    메모리 복사 수행시, 중간에 버퍼를 이용하게 되므로 dest와 src의 해당하는 주소가 겹쳐있는 경우가 있기 때문에 안전하게 복사하기 위한 함수이다.

    dest 시작주소 리턴.

## memchr
    기존 메모리 특정 범위 공간에서 특정 문자 찾기

    while문을 통해 n까지 s에 저장되어있는 데이터를 접근하여 c와 비교한다.

    c와 동일한 문자가 존재한다면 해당 문자의 위치 주소를 리턴한다.

    동일한 문자가 존재하지 않는다면 널 포인터를 반환한다. 

## memcmp
    2개의 기존 메모리에 있는 데이터를 특정 범위 공간까지 비교

    while문을 통해 n까지 각각의 데이터를 비교한다.

    비교 중 같은 위치에 서로 다른 문자가 존재한다면 해당 데이터 간의 ASCII 코드 차이 값을 리턴한다.

    n까지 서로 모든 데이터가 동일하다면 0을 리턴 

## calloc
    malloc 업그레이드 버전
    특정크기를 특정 수만큼 할당

    void *형 포인터 변수를 선언한 후
    size(크기) * nmemb(개수) 만큼 malloc 함수를 통해 초기화.

    malloc 함수를 통해 할당이 실패했을 경우 NULL 포인터 반환.

    성공적으로 할당이 되었다면, 이전에 구현한 ft_bzero 함수를 이용하여 해당 메모리 공간에 '\0' 값으로 모두 초기화한다.

    할당되어진 메모리 주소 반환.

## strdup
    특정 데이터를 새로운 메모리 공간을 할당하여 해당 위치에 데이터 복사.

    복사되어질 메모리 공간을 할당하기 위해 src의 데이터 길이를 계산한다.

    malloc 함수를 통해 (src의 데이터 길이 + 널 종료 문자)만큼의 크기를 할당한다.

    할당 실패 => NULL 포인터 반환

    while문 조건으로 인덱스 변수 i 를 0으로 초기화 한 후, i를 증가시키며 src의 길이만큼 반복한다.
    
    반복되어지는 만큼 할당되어진 공간에
    src의 데이터를 복사한다.

    모든 데이터를 복사한 후 마지막 남은 공간에 널 종료 문자를 추가한다.

    복사되어진 메모리 주소 반환.

## ft_substr
    특정 문자열에서 특정 인덱스부터 특정 크기만큼의 데이터를 추출하여 새로운 메모리 공간에 삽입

    만약 s 데이터의 길이가 start 인덱스 값보다 작다면 1byte의 크기만 메모리 공간을 할당한 후, 해당 공간에 널 종료 문자를 대입한다.

    그게 아니라면 len + 널 종료 문자 만큼의 메모리 공간을 할당한다.

    할당된 메모리 공간에 len 만큼 start 인덱스에 있는 데이터부터 추가한다.

    모두 추가한 후 마지막에 널 종료 문자까지 추가한다.

    할당된 메모리 공간 시작주소 반환.

## ft_strjoin
    2개의 문자열을 연결시킨 결과를 새로운 메모리 공간에 삽입

    만약 s1과 s2가 NULL일 경우 NULL을 리턴.

    할당할 메모리 공간의 크기를 계산하기 위해 s1과 s2의 데이터 길이를 구한다.

    할당되어진 공간에 먼저 s1 데이터를 ft_strlcpy를 통해 복사한다.

    그 후 ft_strlcat을 통해 s2 데이터를 연결시킨다.

    할당된 메모리 주소 반환.

## ft_strtrim
    문자열 처음과 끝에 특정 문자들을 지운다.

    s1의 시작주소와 끝 주소를 구한다.

    문자열 처음에 set에 포함되어있는 문자들이 존재하는지 검사하며 주소를 변경시켜준다.

    똑같이 문자열 끝에 set에 포함되어있는 문자들이 존재하는지 검사하며 주소를 변경시켜준다.

    이때 변경되어진 주소들이 올바르지 못할 경우 널 종료 문자만을 추가하여 반환한다.

    * s1 = "     " , set = " "

    set 문자들이 제거된 후의 문자열의 길이를 계산한 후 메모리 공간을 할당한다.

    ft_strlcpy를 통해 처리된 문자열을 메모리에 복사.

    복사된 메모리 주소 반환.

## ft_split
    특정 구분 문자를 기준으로 문자열을 잘라내어 각 자른 문자열을 메모리 공간에 저장.

<img src="https://dojang.io/pluginfile.php/342/mod_page/content/18/unit34-25.png">

    ft_countstrs : c를 기준으로 자른 문자열들의 개수를 구하는 함수.

    ft_strclen : 구분 문자를 기준으로 잘려진 문자열의 길이를 구하는 함수.

    ft_findstr : 구분 문자를 기준으로 구분된 문자열의 위치주소를 구하는 함수.

abcde, 	12345, 	zzzzzzz,

sptr = ft_findstr( ft_findstr( sptr, c ) + ft_strclen( ft_findstr(sptr, c ), c ), c );

sptr 은 s 문자열을 가리키는 포인터이다.

구분된 문자열을 메모리에 복사하는 과정을 마친 후,

sptr이 가리키는 주소를 다음 구분할 문자열의 위치주소로 변경시켜주어야한다.

ft_findstr 함수에 다음 구분된 문자열의 위치주소와 구분 문자를 넘겨준다.

다음 구분된 문자열을 찾는 방법 : 
이전에 구분된 문자열의 위치주소 + 이전에 구분된 문자열의 길이
= 구분 문자 위치주소

구분 문자 위치주소를 기준으로 ft_findstr 함수에 넘겨주면 다음 구분될 문자열의 위치주소 값을 얻어낼 수 있다.

## ft_itoa
    정수 타입을 문자열로 변환하여 저장

    ft_nbrlen : 변환할 정수의 길이를 구하는 함수.

    ft_putnbr : 부호를 제외한 숫자들을 ASCII 코드 문자값으로 
    변환하여 메모리에 저장하는 함수.

    n이 음수일때 메모리 크기를 1byte 더 확보하여 부호를 저장.

## ft_strmapi
    특정 데이터를 포인터 함수를 통해 가공하여 새로운 메모리 공간에 저장.

    s나 f 함수가 NULL일 경우 NULL 반환.

    s 데이터의 길이를 구하여 메모리 공간 할당.

    s 데이터를 s 데이터 길이만큼 f 함수를 적용시켜 할당된 메모리 공간에 저장.

## ft_putchar_fd
    파일 디스크립터 값을 매개변수 인자로 받아 문자를 write

## ft_putstr_fd
    파일 디스크립터 값을 매개변수 인자로 받아 문자열을 write

    c의 데이터가 ASCII 코드 값에 존재하는 데이터인지의 검사 과정을 거친다.

    검사 과정이 통과되면 write 함수 실행
    
## ft_putendl_fd
    파일 디스크립터 값을 매개변수 인자로 받아 문자열을 write
    
    개행 문자를 char 형 변수로 따로 선언하고 대입하여 write 함수를 실행 후에 마지막에 개행 문자를 write.

## ft_putnbr_fd
    파일 디스크립터 값을 매개변수 인자로 받아 정수를 write
    
    재귀함수를 통해 첫번째 자릿수 값부터 write.

## ft_lstnew
    t_list 구조체를 메모리에 할당.

    t_list *형 변수를 선언하여 t_list의 크기만큼 메모리 공간을 할당.

    할당된 메모리 공간에 있는 content 자리에 매개변수 인자 content 값을 대입.
    
    next 자리에는 NULL로 초기화.

    t_list 구조체 변수가 할당된 메모리 주소를 반환.

## ft_lstadd_front
    매개변수로 인자로 받은 새로운  t_list 구조체를 특정 t_list의 첫번째 리스트로 추가.

    먼저 new의 next 값을 lst의 첫번째 구조체를 가리키게 설정한 후 lst의 첫번째 구조체를 new로 변경.

## ft_lstsize
    t_list 구조체들의 개수를 구하는 함수.

    lst의 next값이 NULL을 만날 때까지 size값을 증가.

## ft_lstlast
    t_list 구조체들 중 마지막 구조체를 조회.

    lst의 next 값이 NULL인 것을 찾는다.

## ft_lstadd_back
    새로운 t_list 구조체를 t_list 구조체의 마지막 부분에 추가.

    lst의 next 값이 NULL 인 구조체까지 접근한 후 next 값을 new 구조체를 가리키도록 설정.

    만약 기존에 구조체 리스트가 존재하지 않는다면 첫번째 인덱스로 new를 추가.

## ft_lstdelone
    구조체를 포인터 함수를 통해 삭제.

    del 포인터 함수 매개변수 인자로 삭제할 구조체의 content 값을 넘겨준다.

    del 함수를 수행 후 free 함수를 통해 메모리 해제.

## ft_lstclear
    모든 구조체들을 포인터 함수를 통해 삭제.

    lst에 있는 모든 구조체의 next 값을 임시 저장한 후 del 함수를 통해 삭제 및 메모리 해제 과정을 수행.

    next값이 NULL일 때까지. 즉 마지막 구조체까지 삭제 및 메모리 해제 과정을 수행한다.

## ft_lstiter
    연결되어져있는 t_list 구조체들의 content값을 포인터 함수를 적용시켜 값을 변경.

    next값이 NULL일 때까지 f 함수 적용.

## ft_lstmap
    기존 t_list 구조체들의 content 값을 포인터 함수를 적용시켜 변경 후 새로운 t_list 구조체 메모리 공간에 저장.

    ft_lstnew 함수를 통해 t_list 구조체 크기만큼의 공간에 f 함수를 적용시킨 구조체를 저장.

    ft_lstnew 함수가 실패했을 경우 ft_lstclear를 통해 모든 구조체를 삭제 및 메모리 해제.

    f 함수를 적용시킨 구조체 간의 연결시키기 위해 적절하게 인덱스를 계산하여 next 값에 다음 구조체를 설정.

    마지막 구조체 공간에 NULL을 가리키도록 설정하여 더 이상 구조체가 없다는 것을 표현.
